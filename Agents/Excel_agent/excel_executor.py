import logging
import os
import tempfile
import mimetypes
from pathlib import Path 
from typing import List, Tuple, Any

from google.adk import Runner
from google.adk.artifacts import InMemoryArtifactService
from google.adk.memory.in_memory_memory_service import InMemoryMemoryService
from google.adk.sessions import InMemorySessionService
from google.genai import types as adk_genai_types 

from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events.event_queue import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import (
    Artifact, FilePart, FileWithBytes, Part, TaskState,
    TaskStatus, TextPart, UnsupportedOperationError
)
from a2a.utils.errors import ServerError

from Agents.Excel_agent.excel_adk import create_excel_agent, agent_file_manager, AGENT_DOWNLOAD_DIR

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

class ADKExcelAgentExecutor(AgentExecutor):
    """An AgentExecutor that runs the ADK-based Excel Analysis Agent."""

    def __init__(self):
        self._agent = create_excel_agent() 
        self.runner = Runner(
            app_name=self._agent.name,
            agent=self._agent,
            artifact_service=InMemoryArtifactService(),
            session_service=InMemorySessionService(),
            memory_service=InMemoryMemoryService(),
        )
        logger.info(f"ADK Runner initialized for agent: {self._agent.name}")

    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ):
        logger.info(f"Starting execution for task {context.task_id} with context {context.context_id}")
        updater = TaskUpdater(event_queue, context.task_id, context.context_id)
        updater.submit() 
        updater.start_work() 

        logger.info(f"Cleaning up previous agent-generated downloads in {AGENT_DOWNLOAD_DIR}...")
        agent_file_manager.clear_session_downloads()
        
        temp_files_to_clean: List[str] = [] 
        final_agent_text_response: str = ""
        
        try:

            augmented_prompt, temp_files_to_clean = await self._prepare_message_and_files(context.message.parts)
            
            adk_agent_input = adk_genai_types.UserContent(parts=[adk_genai_types.Part(text=augmented_prompt)])
            logger.info(f"Prepared ADK agent input: {augmented_prompt}")

            await self._upsert_session(context.context_id) 
            
            async for event in self.runner.run_async(session_id=context.context_id, user_id='a2a_user', new_message=adk_agent_input):
                if event.content and event.content.parts:
                    for part in event.content.parts:
                        if part.text:

                            final_agent_text_response = part.text
                            logger.debug(f"Agent interim text: {part.text[:100]}...")
                if event.is_final_response():
                    logger.info(f"ADK Agent reached final response for session {context.context_id}.")
                    break 

            if not final_agent_text_response:
                final_agent_text_response = "The analysis was completed, but the agent did not provide a direct textual summary."
                logger.warning(f"ADK Agent for session {context.context_id} completed without a direct text response.")


            response_parts: List[Part] = [Part(root=TextPart(text=final_agent_text_response))]

            downloaded_files_by_agent = agent_file_manager.get_all_downloaded_files()
            if downloaded_files_by_agent:
                logger.info(f"Agent generated and downloaded {len(downloaded_files_by_agent)} file(s) to '{AGENT_DOWNLOAD_DIR}'.")
                for file_path in downloaded_files_by_agent:
                    try:
                        with open(file_path, "rb") as f:
                            file_bytes = f.read()
                        
                        file_name = Path(file_path).name
                        mime_type, _ = mimetypes.guess_type(file_name)
                        if not mime_type:
                            mime_type = "application/octet-stream" 

                        a2a_file_part = Part(root=FilePart(
                            file=FileWithBytes(
                                filename=file_name,
                                mime_type=mime_type,
                                bytes=file_bytes
                            )
                        ))
                        response_parts.append(a2a_file_part)
                        logger.info(f"Added generated file '{file_name}' as an A2A artifact.")
                    except Exception as e:
                        logger.error(f"Failed to add generated file '{file_path}' as A2A artifact: {e}")
            else:
                logger.info(f"No files were generated by the agent for task {context.task_id}.")

            updater.add_artifact(response_parts)
            updater.complete()
            yield TaskStatus(state=TaskState.completed) 

        except Exception as e:
            logger.error(f"Error during task execution for {context.task_id}: {e}", exc_info=True)
            updater.failed(error_message=f"Execution failed: {str(e)}")
            yield TaskStatus(state=TaskState.failed) 
        finally:
            for path in temp_files_to_clean:
                try:
                    os.remove(path)
                    logger.info(f"Cleaned up temporary incoming file: {path}")
                except OSError as e:
                    logger.error(f"Error removing temporary incoming file {path}: {e}")

    async def _prepare_message_and_files(self, parts: List[Part]) -> Tuple[str, List[str]]:
        """Saves file parts from A2A request to temp files and creates an augmented prompt for the ADK agent."""
        temp_file_paths: List[str] = []
        text_parts: List[str] = []
        
        for part in parts:
            part_root = part.root 
            if isinstance(part_root, FilePart) and isinstance(part_root.file, FileWithBytes):
                file_suffix = Path(part_root.file.filename or '.tmp').suffix
                fd, tmp_path = tempfile.mkstemp(suffix=file_suffix)
                with os.fdopen(fd, 'wb') as tmp_file:
                    tmp_file.write(part_root.file.bytes)
                temp_file_paths.append(tmp_path)
                logger.info(f"Saved incoming A2A file to temporary path: {tmp_path}")
            elif isinstance(part_root, TextPart):
                text_parts.append(part_root.text)

        user_prompt = " ".join(text_parts)
        if temp_file_paths:
            path_info = "The user has provided excel files located at the following paths: " + \
                        ", ".join(f"'{p}'" for p in temp_file_paths) + ". "
            return f"{path_info}\n\nUser request: {user_prompt}", temp_file_paths
        
        return user_prompt, temp_file_paths

    async def _upsert_session(self, session_id: str):
        """Creates an ADK session if it doesn't exist for the ADK Runner."""
        session = await self.runner.session_service.get_session(
            app_name=self.runner.app_name, user_id='a2a_user', session_id=session_id
        )
        if not session:
            logger.info(f"Creating new ADK session: {session_id}")
            session = await self.runner.session_service.create_session(
                app_name=self.runner.app_name, user_id='a2a_user', session_id=session_id
            )
        return session

    async def cancel(self, context: RequestContext, event_queue: EventQueue):
        logger.warning(f"Cancellation requested for task {context.task_id}, but not fully supported.")
        raise ServerError(error=UnsupportedOperationError())