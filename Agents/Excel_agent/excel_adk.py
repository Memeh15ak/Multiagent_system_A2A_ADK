import os
import mimetypes
import logging
from typing import List, Dict, Any, Optional
from pathlib import Path

from google.adk.agents import Agent
from google.adk.models.lite_llm import LiteLlm
import anthropic

logging.basicConfig(level=logging.INFO, format='%(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

MODEL_FOR_CODE_EXECUTION_LITELLM = "anthropic/claude-sonnet-4-20250514"
MODEL_FOR_CODE_EXECUTION_ANTHROPIC_SDK = "claude-sonnet-4-20250514"

AGENT_DOWNLOAD_DIR = "agent_downloads"
anthropic_client: Optional[anthropic.Anthropic] = None

class AgentFileManager:
    """Manages files downloaded *from* Anthropic by the agent during a session."""

    def __init__(self):
        self._downloaded_by_agent: List[str] = []
        os.makedirs(AGENT_DOWNLOAD_DIR, exist_ok=True)
        logger.info(f"Agent download directory initialized: {os.path.abspath(AGENT_DOWNLOAD_DIR)}")

    def _extract_file_ids_from_claude_response(self, response: Any) -> List[str]:
        """Extract file IDs from Claude's code execution response based on original logic."""
        file_ids = []
        if response and hasattr(response, 'content') and response.content:
            for item in response.content:
                if item.type == 'code_execution_tool_result':
                    content_item = item.content
                    if isinstance(content_item, dict) and content_item.get('type') == 'code_execution_result':
                        for file in content_item.get('content', []):
                            if isinstance(file, dict) and 'file_id' in file:
                                file_ids.append(file['file_id'])
        return file_ids

    def download_generated_files(self, claude_response_obj: Any) -> List[str]:
        """Download files generated by Claude's code execution from a raw Claude Message object."""
        if not anthropic_client:
            logger.error("Anthropic client not initialized for downloading files. Cannot download.")
            return []
        
        os.makedirs(AGENT_DOWNLOAD_DIR, exist_ok=True) 
        current_downloaded_files = []
        file_ids = self._extract_file_ids_from_claude_response(claude_response_obj)
        
        if not file_ids:
            logger.info("No file IDs found in Claude's response for download.")
            return []

        for file_id in file_ids:
            try:
                file_metadata = anthropic_client.beta.files.retrieve_metadata(file_id)
                filename = file_metadata.filename
                file_content_stream = anthropic_client.beta.files.download(file_id)
                
                file_path = os.path.abspath(os.path.join(AGENT_DOWNLOAD_DIR, filename))
                with open(file_path, "wb") as f:
                    f.write(file_content_stream.read()) 
                
                current_downloaded_files.append(file_path)
                self._downloaded_by_agent.append(file_path) 
                logger.info(f"Downloaded: {file_path}")
                
            except Exception as e:
                logger.error(f"Error downloading file {file_id}: {e}")
    
        return current_downloaded_files

    def clear_session_downloads(self):
        """Clears all locally downloaded files from the AGENT_DOWNLOAD_DIR."""
        logger.info(f"Clearing previous downloads from {os.path.abspath(AGENT_DOWNLOAD_DIR)}")
        for filename in os.listdir(AGENT_DOWNLOAD_DIR):
            file_path = os.path.join(AGENT_DOWNLOAD_DIR, filename)
            try:
                if os.path.isfile(file_path):
                    os.remove(file_path)
                    logger.debug(f"Deleted old download file: {file_path}")
            except Exception as e:
                logger.error(f"Error deleting old download file {file_path}: {e}")
        self._downloaded_by_agent.clear()
        logger.info("Agent download directory cleaned.")

    def get_all_downloaded_files(self) -> List[str]:
        """Returns the list of all files downloaded by the agent in the current session."""
        return list(self._downloaded_by_agent)

agent_file_manager = AgentFileManager()

# --- Tool Functions ---
def analyze_spreadsheet_with_claude(file_path: str, query: str, create_visualization: bool) -> Dict:
    """
    Tool: Uploads a CSV or XLSX file to Claude and asks Claude to analyze it using its Code Execution tool.
    Can optionally request visualizations to be created.
    """
    logger.info(f"Tool: analyze_spreadsheet_with_claude called for file: {file_path}, query: '{query}', visualization: {create_visualization}")

    global anthropic_client 
    if not anthropic_client:
        return {"status": "error", "error_message": "Anthropic client not initialized (API key missing or invalid)."}

    if not os.path.exists(file_path):
        return {"status": "error", "error_message": f"File not found: {file_path}"}

    file_name = Path(file_path).name 
    
    if file_path.lower().endswith(".csv"):
        mime_type = "text/csv"
    elif file_path.lower().endswith((".xls", ".xlsx")):
        mime_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    else:
        guessed_mime_type, _ = mimetypes.guess_type(file_path)
        mime_type = guessed_mime_type if guessed_mime_type else "application/octet-stream"

    logger.info(f"Attempting to upload '{file_name}' with MIME type: {mime_type}")

    uploaded_file_id = None
    try:
        with open(file_path, "rb") as f:
            uploaded_file_object = anthropic_client.beta.files.upload(
                file=(file_name, f, mime_type),
            )
        uploaded_file_id = uploaded_file_object.id
        logger.info(f"File uploaded successfully. File ID: {uploaded_file_id}")

        base_query = f"Please analyze the data in the uploaded file (ID: {uploaded_file_id}). {query}. Use your code execution capabilities to process the file."
        
        if create_visualization:
            base_query += " Please also create appropriate visualizations and save them as PNG files."

        user_message_content = [
            {
                "type": "text",
                "text": base_query
            },
            {
                "type": "container_upload", 
                "file_id": uploaded_file_id
            }
        ]
        
        messages_for_claude = [{"role": "user", "content": user_message_content}]

        logger.info(f"Sending request to Claude ({MODEL_FOR_CODE_EXECUTION_ANTHROPIC_SDK}) for analysis using Code Execution Tool...")
        
        claude_response = anthropic_client.messages.create(
            model=MODEL_FOR_CODE_EXECUTION_ANTHROPIC_SDK,
            max_tokens=4096,  
            messages=messages_for_claude,
            tools=[{ 
                "type": "code_execution_20250522",
                "name": "code_execution"
            }]
        )

        analysis_text = ""
        if claude_response.content:
            for block in claude_response.content:
                if block.type == "text":
                    analysis_text += block.text + "\n"

        final_analysis = analysis_text.strip()
        logger.info(f"Claude's raw analysis response: {final_analysis}")

        downloaded_files = []
        if create_visualization:
            downloaded_files = agent_file_manager.download_generated_files(claude_response)

        if not final_analysis and downloaded_files:
            final_analysis = f"Claude processed the file and generated visualization(s): {', '.join([Path(f).name for f in downloaded_files])}."
        elif not final_analysis and claude_response.stop_reason == 'tool_use':
             final_analysis = "Claude decided to use a tool. Waiting for its full response if this was an intermediate step."
        elif not final_analysis: 
             final_analysis = "Claude processed the file, but no direct textual summary was found in this response segment."


        result = {
            "status": "success", 
            "analysis": final_analysis,
            "downloaded_files": downloaded_files 
        }
        
        return result

    except anthropic.APIError as e:
        error_message_detail = str(e)
        if hasattr(e, 'body') and e.body and isinstance(e.body, dict) and 'error' in e.body and isinstance(e.body['error'], dict) and 'message' in e.body['error']:
            error_message_detail = e.body['error']['message']
        elif hasattr(e, 'message') and e.message:
             error_message_detail = e.message
        
        full_error_message = f"Anthropic API Error (Code: {e.status_code if hasattr(e, 'status_code') else 'N/A'}): {error_message_detail}"
        logger.error(full_error_message, exc_info=True)
        return {"status": "error", "error_message": full_error_message}
    except Exception as e:
        logger.error(f"An unexpected error occurred in analyze_spreadsheet_with_claude: {e}", exc_info=True)
        return {"status": "error", "error_message": f"An unexpected error: {str(e)}"}


def create_visualization_only(query: str, output_filename: str = "") -> Dict: 
    """
    Tool: Create a visualization without uploading a file - for custom visualization requests.
    Claude will decide the filename and save location internally.
    """
    logger.info(f"Tool: create_visualization_only called with query: '{query}'")

    global anthropic_client 

    if not anthropic_client:
        return {"status": "error", "error_message": "Anthropic client not initialized (API key missing or invalid)."}

    try:
        messages_for_claude = [{"role": "user", "content": query + " Please create appropriate visualizations and save them as PNG files."}]

        logger.info(f"Sending visualization request to Claude ({MODEL_FOR_CODE_EXECUTION_ANTHROPIC_SDK})...")
        
        claude_response = anthropic_client.messages.create(
            model=MODEL_FOR_CODE_EXECUTION_ANTHROPIC_SDK,
            max_tokens=4096,  
            messages=messages_for_claude,
            tools=[{ 
                "type": "code_execution_20250522",
                "name": "code_execution"
            }]
        )

        analysis_text = ""
        if claude_response.content:
            for block in claude_response.content:
                if block.type == "text":
                    analysis_text += block.text + "\n"

        downloaded_files = agent_file_manager.download_generated_files(claude_response)
        
        if not analysis_text and downloaded_files:
            analysis_text = f"Claude processed your request and generated visualization(s): {', '.join([Path(f).name for f in downloaded_files])}."
        elif not analysis_text: 
             analysis_text = "Claude processed your request, but no direct textual summary was found in this response."

        return {
            "status": "success", 
            "analysis": analysis_text.strip(),
            "downloaded_files": downloaded_files
        }

    except Exception as e:
        logger.error(f"An unexpected error occurred in create_visualization_only: {e}", exc_info=True)
        return {"status": "error", "error_message": f"An unexpected error: {str(e)}"}


def create_excel_agent() -> Agent:
    """
    Creates and returns the ADK Agent for Excel analysis.
    This function is called by the A2A executor to get the ADK agent instance.
    """
    global anthropic_client 
    if anthropic_client is None:
        try:
            anthropic_client = anthropic.Anthropic(
                api_key=os.getenv("ANTHROPIC_API_KEY"),
                default_headers={
                    "anthropic-beta": "code-execution-2025-05-22,files-api-2025-04-14"
                }
            )
            if os.getenv("ANTHROPIC_API_KEY"):
                anthropic_client.models.list() 
                logger.info("Anthropic client successfully initialized within agent module.")
            else:
                logger.warning("ANTHROPIC_API_KEY is not set. Anthropic client will not function in agent.")
        except anthropic.APIKeyMissingError:
            logger.error("ANTHROPIC_API_KEY missing during agent client init.")
            anthropic_client = None
        except Exception as e:
            logger.error(f"Error initializing Anthropic client in agent module: {e}")
            anthropic_client = None
    memory = [
        "Previously, `sales_Q1_2024.xlsx` was analyzed for total revenue.",
        "The user once asked for a line chart of `customer_growth.csv` by month.",
        "The last file queried was `expense_report_march.csv`, focusing on travel costs.",
        "User preference: All numerical results should be rounded to two decimal places.",
        "User preference: For time-series data, prefer line charts over bar charts unless specified.",
        "User preference: Summaries should always include top 3 and bottom 3 items.",
    ]


    return Agent(
        name="excel_analyzer_claude_code_exec",
        model=LiteLlm(model=MODEL_FOR_CODE_EXECUTION_LITELLM), 
        description="Analyzes CSV or XLSX files using Claude's Code Execution tool and can create visualizations. Integrates with A2A protocol.",
    instruction=f"""
    You are an intelligent data analyst agent. Your job is to select the correct tool based on the user's request and intelligently use past context.

    **Your Thought Process:**

    **Step 1: Identify Target File(s) & User Intent from Query and Memory.**
    - Read the user's query carefully.
    - **Identify explicit file names:** Look for specific file names (e.g., `data.csv`, `report.xlsx`, `dashboard.json`) in the current query.
    - **Identify implicit file references & consult `Memory Context`:**
        - If the user's query implies a reference to a previously processed file (e.g., "what about the sales data?", "show me the last report", "that budget file from last year"), scan `Memory Context` for entries containing keywords that match the implied subject.
        - If a strong match is found (e.g., "sales data" implies `sales_Q1_2024.xlsx`, "last report" implies `expense_report_march.csv`), *internally* resolve the implied subject to the explicit filename(s) found in memory.
    - **Consolidate File List:** Create a definitive list of all target files, combining explicitly mentioned files and any files resolved from `Memory Context`. If no files are identified, state that a file needs to be provided or referenced.
    - **Identify Core Task:** Determine if the user is asking for a 'chart', 'graph', 'plot', 'visualization', or 'diagram' (visualization task) or for 'summaries', 'calculations', 'questions', 'cleaning' (data querying task).

    **Step 2: Formulate Tool Call based on Task and Identified Files.**

    **TOOL ROUTING LOGIC:**

    1.  **If the user asks for a 'chart', 'graph', 'plot', 'visualization', or 'diagram'**:
        - You MUST use the `create_visualization_only` tool.
        - For each file in your consolidated list from Step 1:
            - The `file_path` argument MUST be the specific file path (e.g., `sales_Q1_2024.xlsx`).
            - The `request` argument for this tool should be the user's full instruction for the chart. **Enhance this `request` using user preferences from `Memory Context`** (e.g., "create a line chart of X by Y", if memory indicates a preference for line charts).

    2.  **For ALL OTHER requests involving data (summaries, calculations, questions, cleaning)**:
        - You MUST use the `query_data_file` tool.
        - This tool is for text-based answers only.
        - For each file in your consolidated list from Step 1:
            - The `file_path` argument MUST be the specific file path.
            - The `query` argument should be the user's specific question or task. **Enhance this `query` using user preferences from `Memory Context`** (e.g., "summarize this document, including top 3 and bottom 3 items", if memory indicates this preference).

    **RULES:**
    - If a prompt mentions multiple files (explicitly or implicitly resolved), create a separate tool call for each file for the relevant tool (`query_data_file` or `create_visualization_only`).
    - The `file_path` provided to the tool MUST always be an explicit file path string. If resolved from memory, it becomes explicit for the tool.
    - If the tool returns an error message (e.g., "File not found"), you must relay that error clearly and politely to the user.

    ---

    **General Memory Handling Instructions:**
    - Always review the `Memory Context` provided below.
    - **Only use information from `Memory Context` if it is directly relevant to your specific role (data analysis and visualization) and the current user query.**
      *   For example, if `Memory Context` contains a fact like "The last file queried was `expense_report_march.csv`", and the user asks "What were the travel costs?", you should resolve this to `expense_report_march.csv` and pass that `file_path` to the `query_data_file` tool.
      *   If `Memory Context` states "User preference: All numerical results should be rounded to two decimal places", incorporate this into your `query` argument for the tool (e.g., `query='Calculate total sales, round result to two decimal places.'`).
      *   If `Memory Context` states "I enjoy learning about ancient Roman history" and the query is "Summarize `budget.xlsx`", this memory is not relevant to data analysis, so you MUST ignore it for this query.
    - If information in `Memory Context` is not relevant to your current task or query, you MUST ignore it and proceed with your core responsibilities. Do not try to answer questions outside your domain based on this memory.

    **Memory Context:** {memory}
    """,
        tools=[analyze_spreadsheet_with_claude, create_visualization_only],
    )